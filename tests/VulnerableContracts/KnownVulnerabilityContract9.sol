// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title BadRandomnessVulnerable
 * @dev Contract with weak randomness generation
 * Based on block variables and predictable entropy sources
 */
contract BadRandomnessVulnerable {
    mapping(address => uint256) public deposits;
    uint256 public jackpot;
    address[] public players;
    
    event Winner(address indexed player, uint256 amount);
    event GamePlayed(address indexed player, uint256 roll, bool won);
    
    function deposit() public payable {
        require(msg.value >= 0.01 ether, "Minimum 0.01 ETH");
        deposits[msg.sender] += msg.value;
        jackpot += msg.value / 10; // 10% goes to jackpot
        players.push(msg.sender);
    }
    
    // VULNERABILITY: Weak randomness using block variables
    function playDice() public {
        require(deposits[msg.sender] >= 0.01 ether, "Insufficient deposit");
        
        deposits[msg.sender] -= 0.01 ether;
        
        // VULNERABILITY: Predictable randomness
        uint256 random = uint256(keccak256(abi.encodePacked(
            block.timestamp,    // Predictable by miners
            block.difficulty,   // Known value
            block.number,       // Known value
            msg.sender          // Known value
        ))) % 6 + 1;
        
        bool won = random >= 4; // 50% chance to win
        
        if (won) {
            payable(msg.sender).transfer(0.019 ether); // Win 0.019 ETH
        }
        
        emit GamePlayed(msg.sender, random, won);
    }
    
    // VULNERABILITY: Even weaker randomness
    function quickLottery() public {
        require(players.length >= 3, "Need at least 3 players");
        
        // VULNERABILITY: Only using block.timestamp
        uint256 winnerIndex = block.timestamp % players.length;
        address winner = players[winnerIndex];
        
        uint256 prize = jackpot;
        jackpot = 0;
        
        payable(winner).transfer(prize);
        emit Winner(winner, prize);
        
        // Reset players
        delete players;
    }
    
    // VULNERABILITY: Predictable sequence
    uint256 private seed = 12345; // Fixed seed
    
    function generateNumber() public returns (uint256) {
        // VULNERABILITY: Linear congruential generator with known parameters
        seed = (seed * 1103515245 + 12345) % 2**31;
        return seed;
    }
    
    function playWithSeed() public {
        require(deposits[msg.sender] >= 0.01 ether, "Insufficient deposit");
        
        deposits[msg.sender] -= 0.01 ether;
        
        uint256 roll = generateNumber() % 100;
        
        if (roll < 45) { // 45% chance to win
            payable(msg.sender).transfer(0.022 ether);
        }
    }
    
    // VULNERABILITY: Using blockhash for recent blocks
    function recentBlockLottery() public {
        require(deposits[msg.sender] >= 0.05 ether, "Need 0.05 ETH");
        
        deposits[msg.sender] -= 0.05 ether;
        
        // VULNERABILITY: Recent block hashes are predictable/manipulable
        bytes32 hash = blockhash(block.number - 1);
        uint256 random = uint256(hash) % 10;
        
        if (random == 7) { // 10% chance
            payable(msg.sender).transfer(0.5 ether); // Big win
        }
    }
    
    // VULNERABILITY: Entropy source manipulation
    function minerInfluencedLottery() public payable {
        require(msg.value == 0.1 ether, "Must bet 0.1 ETH");
        
        // VULNERABILITY: Miners can influence these values
        uint256 entropy = uint256(keccak256(abi.encodePacked(
            block.coinbase,     // Miner's address
            block.gaslimit,     // Can be influenced
            gasleft()           // Predictable
        )));
        
        if (entropy % 2 == 0) {
            payable(msg.sender).transfer(0.19 ether); // Almost 2x return
        }
    }
}
