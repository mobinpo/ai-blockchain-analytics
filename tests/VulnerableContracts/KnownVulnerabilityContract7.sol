// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title UninitialisedStorageVulnerable
 * @dev Contract with uninitialised storage vulnerabilities
 * Based on storage collision and uninitialized pointer bugs
 */
contract UninitialisedStorageVulnerable {
    address public owner;
    mapping(address => uint256) public balances;
    address[] public users;
    
    struct User {
        address addr;
        uint256 balance;
        bool isActive;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    // VULNERABILITY: Uninitialized storage struct
    function createUser() public {
        User memory newUser; // Uninitialized - points to storage slot 0
        newUser.addr = msg.sender;
        newUser.balance = 1000;
        newUser.isActive = true;
        
        // This overwrites storage slot 0 (owner variable)
        users.push(newUser.addr);
    }
    
    // VULNERABILITY: Array bounds not checked
    function getUserBalance(uint256 index) public view returns (uint256) {
        // No bounds checking - can read arbitrary storage
        return balances[users[index]];
    }
    
    // VULNERABILITY: Dynamic array length manipulation
    function removeUser(uint256 index) public {
        require(msg.sender == owner, "Only owner");
        
        // VULNERABILITY: No bounds check, can cause underflow
        if (index >= users.length) {
            users.pop(); // This can cause issues
        } else {
            users[index] = users[users.length - 1];
            users.pop();
        }
    }
    
    // VULNERABILITY: Delegatecall with storage collision
    mapping(address => address) public implementations;
    
    function setImplementation(address impl) public {
        implementations[msg.sender] = impl;
    }
    
    function delegateToImplementation(bytes calldata data) public {
        address impl = implementations[msg.sender];
        
        // VULNERABILITY: Storage collision possible
        (bool success, ) = impl.delegatecall(data);
        require(success, "Delegatecall failed");
    }
    
    // VULNERABILITY: Uninitialized function pointer
    function executeFunction(uint256 functionId) public {
        function() internal funcPtr;
        
        if (functionId == 1) {
            funcPtr = internalFunction1;
        } else if (functionId == 2) {
            funcPtr = internalFunction2;
        }
        // If functionId is neither 1 nor 2, funcPtr remains uninitialized
        
        funcPtr(); // Calling uninitialized function pointer
    }
    
    function internalFunction1() internal pure {}
    function internalFunction2() internal pure {}
}
