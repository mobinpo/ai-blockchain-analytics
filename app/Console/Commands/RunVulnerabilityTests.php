<?php

declare(strict_types=1);

namespace App\Console\Commands;

use App\Services\SolidityCleanerService;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

final class RunVulnerabilityTests extends Command
{
    protected $signature = 'vulnerability:test 
                          {--contract= : Test specific contract by name}
                          {--type= : Test specific vulnerability type}
                          {--save-results : Save test results to database}
                          {--detailed : Show detailed output}';

    protected $description = 'Run vulnerability regression tests against known vulnerable contracts';

    public function __construct(
        private readonly SolidityCleanerService $solidityCleanerService
    ) {
        parent::__construct();
    }

    public function handle(): int
    {
        $this->info('🔍 Running Vulnerability Regression Tests');
        
        $startTime = microtime(true);
        $contractFilter = $this->option('contract');
        $typeFilter = $this->option('type');
        $saveResults = $this->option('save-results');
        $detailed = $this->option('detailed');

        // Load test data
        $testData = $this->loadTestData($contractFilter, $typeFilter);
        
        if (empty($testData)) {
            $this->error('No test data found');
            return self::FAILURE;
        }

        $this->info("📋 Found " . count($testData) . " test cases");

        // Run tests
        $results = $this->runTests($testData, $detailed);

        // Display summary
        $this->displaySummary($results, microtime(true) - $startTime);

        return $results['failed_tests'] > 0 ? self::FAILURE : self::SUCCESS;
    }

    private function loadTestData(?string $contractFilter, ?string $typeFilter): array
    {
        $query = DB::table('vulnerability_test_data');

        if ($contractFilter) {
            $query->where('contract_name', 'like', "%{$contractFilter}%");
        }

        if ($typeFilter) {
            $query->where('vulnerability_type', $typeFilter);
        }

        return $query->get()->toArray();
    }

    private function runTests(array $testData, bool $detailed): array
    {
        $results = [
            'total_tests' => count($testData),
            'passed_tests' => 0,
            'failed_tests' => 0,
            'test_details' => []
        ];

        foreach ($testData as $test) {
            $testResult = $this->runSingleTest($test, $detailed);
            
            if ($testResult['passed']) {
                $results['passed_tests']++;
            } else {
                $results['failed_tests']++;
            }

            $results['test_details'][] = $testResult;
        }

        return $results;
    }

    private function runSingleTest(object $test, bool $detailed): array
    {
        $startTime = microtime(true);
        
        try {
            // Clean the contract code
            $cleanedCode = $this->solidityCleanerService->quickCleanForPrompt($test->contract_code);
            $expectedFindings = json_decode($test->expected_findings, true);

            // Basic vulnerability detection
            $detected = $this->detectBasicVulnerabilities($cleanedCode, $test->vulnerability_type);
            
            $processingTime = round((microtime(true) - $startTime) * 1000);
            
            $testResult = [
                'contract_name' => $test->contract_name,
                'vulnerability_type' => $test->vulnerability_type,
                'passed' => count($detected) > 0,
                'detected_count' => count($detected),
                'processing_time_ms' => $processingTime
            ];

            if ($detailed) {
                $status = $testResult['passed'] ? '✅ PASS' : '❌ FAIL';
                $this->line("{$test->contract_name} ({$test->vulnerability_type}) - {$status}");
            }

            return $testResult;

        } catch (\Exception $e) {
            return [
                'contract_name' => $test->contract_name,
                'vulnerability_type' => $test->vulnerability_type,
                'passed' => false,
                'detected_count' => 0,
                'processing_time_ms' => round((microtime(true) - $startTime) * 1000),
                'error' => $e->getMessage()
            ];
        }
    }

    private function detectBasicVulnerabilities(string $code, string $type): array
    {
        $detected = [];

        // Basic pattern matching
        switch ($type) {
            case 'reentrancy':
                if (strpos($code, '.call{value:') !== false) $detected[] = 'external_call';
                if (strpos($code, 'balances[msg.sender] -=') !== false) $detected[] = 'state_change';
                break;
            
            case 'broken_access_control':
                if (strpos($code, 'tx.origin') !== false) $detected[] = 'tx_origin';
                if (strpos($code, '!= owner') !== false) $detected[] = 'inverted_logic';
                break;
                
            case 'unchecked_external_call':
                if (strpos($code, '.call{') !== false) $detected[] = 'external_call';
                if (strpos($code, '.delegatecall(') !== false) $detected[] = 'delegatecall';
                break;
                
            case 'weak_randomness':
                if (strpos($code, 'block.timestamp') !== false) $detected[] = 'timestamp';
                if (strpos($code, 'blockhash(') !== false) $detected[] = 'blockhash';
                break;
        }

        return $detected;
    }

    private function displaySummary(array $results, float $totalTime): void
    {
        $successRate = $results['total_tests'] > 0 
            ? round(($results['passed_tests'] / $results['total_tests']) * 100, 2) 
            : 0;

        $this->info('📊 Test Results Summary');
        $this->table(
            ['Metric', 'Value'],
            [
                ['Total Tests', $results['total_tests']],
                ['Passed Tests', $results['passed_tests']],
                ['Failed Tests', $results['failed_tests']],
                ['Success Rate', $successRate . '%'],
                ['Total Time', round($totalTime, 2) . ' seconds'],
            ]
        );

        if ($successRate >= 80) {
            $this->info('🎉 Excellent! Vulnerability detection is working well.');
        } elseif ($successRate >= 60) {
            $this->warn('⚠️ Good results, but some improvements needed.');
        } else {
            $this->error('❌ Poor results. Detection needs improvement.');
        }
    }
}