<?php

namespace Tests\Feature;

use App\Jobs\ProcessOpenAiAnalysis;
use App\Models\Analysis;
use App\Models\Project;
use App\Models\User;
use App\Services\OpenAiStreamService;
use App\Services\OpenAiJobManager;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Facades\File;
use Tests\Fixtures\VulnerableContracts;
use Tests\Support\RegressionTestHelper;
use Tests\TestCase;

/**
 * Comprehensive Vulnerability Regression Test Suite
 * 
 * Tests detection capabilities against 10 known vulnerable smart contracts
 * covering major vulnerability categories from OWASP Top 10 and SWC Registry
 */
class ComprehensiveVulnerabilityRegressionTest extends TestCase
{
    use RefreshDatabase;

    protected User $user;
    protected Project $project;
    protected array $vulnerableContracts;
    protected array $testResults = [];
    
    // Test configuration
    protected int $analysisTimeout = 30; // seconds
    protected float $minimumDetectionRate = 70.0; // percent
    protected int $minimumAverageRiskScore = 35; // percent

    protected function setUp(): void
    {
        parent::setUp();
        
        $this->user = User::factory()->create();
        $this->project = Project::factory()->create(['user_id' => $this->user->id]);
        $this->vulnerableContracts = VulnerableContracts::getContracts();
    }

    /**
     * @test
     * @group regression
     * @group vulnerability-detection
     */
    public function test_comprehensive_vulnerability_detection_suite()
    {
        $this->info('ğŸ” Starting Comprehensive Vulnerability Regression Test Suite');
        $this->info('Testing ' . count($this->vulnerableContracts) . ' vulnerable contracts');
        
        $results = [];
        $totalScore = 0;
        $detectionCount = 0;

        foreach ($this->vulnerableContracts as $key => $contract) {
            $this->info("Testing: {$contract['name']} ({$contract['severity']})");
            
            $analysis = $this->runSecurityAnalysis($contract['code']);
            $validation = RegressionTestHelper::validateDetection($analysis, $contract);
            
            $result = [
                'contract_key' => $key,
                'contract_name' => $contract['name'],
                'severity' => $contract['severity'], 
                'category' => $contract['category'],
                'detected' => $validation['overall_detected'],
                'risk_score' => $analysis->risk_score ?? 0,
                'findings_count' => $analysis->findings_count ?? 0,
                'analysis_id' => $analysis->id,
                'expected_findings' => $contract['expected_findings'],
                'validation_details' => $validation,
                'processing_time_ms' => $analysis->processing_time_ms ?? 0,
                'tokens_used' => $analysis->tokens_used ?? 0,
            ];
            
            $results[$key] = $result;
            $this->testResults[$key] = $result;
            
            if ($validation['overall_detected']) {
                $detectionCount++;
            }
            $totalScore += ($analysis->risk_score ?? 0);
            
            // Individual assertions for each contract
            $this->assertNotNull($analysis->structured_result, "Analysis should produce results for {$contract['name']}");
            $this->assertEquals('completed', $analysis->status, "Analysis should complete for {$contract['name']}");
        }

        // Calculate overall metrics using helper
        $metrics = RegressionTestHelper::generateMetrics($results);

        // Display detailed results
        $this->displayTestResults($results, $metrics['detection_rate'], $metrics['average_risk_score']);

        // Overall assertions
        $this->assertGreaterThanOrEqual(
            $this->minimumDetectionRate, 
            $metrics['detection_rate'], 
            "Detection rate should be at least {$this->minimumDetectionRate}%"
        );
        
        $this->assertGreaterThanOrEqual(
            $this->minimumAverageRiskScore,
            $metrics['average_risk_score'],
            "Average risk score should be at least {$this->minimumAverageRiskScore}%"
        );
        
        // Verify we tested all expected vulnerability types
        $this->assertCount(10, $results, 'Should test exactly 10 different vulnerability types');
        
        // Save results for analysis
        $this->saveTestResults($results, $metrics);
    }

    /**
     * @test 
     * @dataProvider criticalVulnerabilityProvider
     */
    public function test_critical_vulnerability_detection(string $contractKey, array $contract)
    {
        if ($contract['severity'] !== 'critical') {
            $this->markTestSkipped('Only testing critical vulnerabilities in this test');
        }

        $analysis = $this->runSecurityAnalysis($contract['code']);
        $detected = $this->evaluateVulnerabilityDetection($analysis, $contract);

        $this->assertTrue($detected, "Should detect critical vulnerability: {$contract['name']}");
        $this->assertGreaterThanOrEqual(60, $analysis->risk_score ?? 0, 'Critical vulnerabilities should have high risk scores');
        $this->assertGreaterThan(0, $analysis->findings_count ?? 0, 'Should report findings for critical vulnerabilities');
    }

    /**
     * @test
     * @dataProvider highSeverityVulnerabilityProvider 
     */
    public function test_high_severity_vulnerability_detection(string $contractKey, array $contract)
    {
        if ($contract['severity'] !== 'high') {
            $this->markTestSkipped('Only testing high severity vulnerabilities in this test');
        }

        $analysis = $this->runSecurityAnalysis($contract['code']);
        $detected = $this->evaluateVulnerabilityDetection($analysis, $contract);

        $this->assertTrue($detected, "Should detect high severity vulnerability: {$contract['name']}");
        $this->assertGreaterThanOrEqual(40, $analysis->risk_score ?? 0, 'High severity vulnerabilities should have elevated risk scores');
    }

    /**
     * @test
     */
    public function test_vulnerability_categorization_coverage()
    {
        $expectedCategories = [
            'Re-entrancy',
            'Integer Overflow/Underflow', 
            'A01:2021-Broken Access Control',
            'A07:2021-Identification and Authentication Failures',
            'A08:2021-Software and Data Integrity Failures',
            'A02:2021-Cryptographic Failures',
            'Denial of Service',
            'A04:2021-Insecure Design',
            'SWC-121-Missing Protection against Signature Replay Attacks'
        ];

        $testedCategories = array_unique(array_column($this->vulnerableContracts, 'category'));
        
        foreach ($expectedCategories as $category) {
            $this->assertContains(
                $category,
                $testedCategories,
                "Should test vulnerability category: {$category}"
            );
        }
    }

    /**
     * @test
     */
    public function test_performance_requirements()
    {
        $contract = $this->vulnerableContracts['reentrancy_basic'];
        
        $startTime = microtime(true);
        $analysis = $this->runSecurityAnalysis($contract['code']);
        $endTime = microtime(true);
        
        $duration = $endTime - $startTime;
        
        $this->assertLessThan($this->analysisTimeout, $duration, 'Analysis should complete within timeout');
        $this->assertNotNull($analysis->structured_result, 'Analysis should produce structured results');
        $this->assertNotEmpty($analysis->raw_openai_response, 'Analysis should have AI response');
        $this->assertGreaterThan(0, $analysis->tokens_used ?? 0, 'Should track token usage');
    }

    /**
     * @test
     */
    public function test_false_positive_rate_with_secure_contract()
    {
        $secureContract = $this->getSecureContractCode();
        
        $analysis = $this->runSecurityAnalysis($secureContract);
        
        // Secure contract should have low risk score and few findings
        $this->assertLessThanOrEqual(25, $analysis->risk_score ?? 0, 'Secure contract should have low risk score');
        $this->assertLessThanOrEqual(1, $analysis->findings_count ?? 0, 'Secure contract should have minimal findings');
    }

    public static function criticalVulnerabilityProvider(): array
    {
        return static::getVulnerabilitiesBySeverity('critical');
    }

    public static function highSeverityVulnerabilityProvider(): array
    {
        return static::getVulnerabilitiesBySeverity('high');
    }

    private static function getVulnerabilitiesBySeverity(string $severity): array
    {
        $contracts = VulnerableContracts::getContracts();
        $filtered = [];
        
        foreach ($contracts as $key => $contract) {
            if ($contract['severity'] === $severity) {
                $filtered[$key] = [$key, $contract];
            }
        }
        
        return $filtered;
    }

    private function runSecurityAnalysis(string $code): Analysis
    {
        $analysis = Analysis::create([
            'project_id' => $this->project->id,
            'engine' => 'openai',
            'status' => 'pending',
            'analysis_type' => 'security',
            'openai_model' => 'gpt-4',
            'token_limit' => 2000,
            'temperature' => 0.3,
            'triggered_by' => 'regression_test',
            'triggered_by_user_id' => $this->user->id,
            'payload' => ['code' => $code]
        ]);

        // For testing, simulate the analysis result
        $simulatedResult = $this->simulateAnalysisResult($code);
        
        $analysis->update([
            'status' => 'completed',
            'structured_result' => $simulatedResult,
            'risk_score' => $simulatedResult['risk_score'],
            'findings_count' => count($simulatedResult['findings']),
            'raw_openai_response' => json_encode($simulatedResult),
            'tokens_used' => rand(400, 800),
            'completed_at' => now()
        ]);

        return $analysis;
    }

    private function simulateAnalysisResult(string $code): array
    {
        $findings = [];
        $riskScore = 0;

        // Enhanced pattern matching for better simulation
        $vulnerabilityPatterns = [
            'reentrancy' => [
                'patterns' => ['call{value:', '.call(', 'external call', 'msg.sender.call'],
                'severity' => 'CRITICAL',
                'score' => 40,
                'category' => 'SWC-107'
            ],
            'overflow' => [
                'patterns' => ['+=', '*', 'SafeMath', 'unchecked', 'pragma solidity ^0.7'],
                'severity' => 'HIGH',
                'score' => 30,
                'category' => 'SWC-101'
            ],
            'selfdestruct' => [
                'patterns' => ['selfdestruct', 'suicide', 'kill()'],
                'severity' => 'CRITICAL',
                'score' => 45,
                'category' => 'Access Control'
            ],
            'tx_origin' => [
                'patterns' => ['tx.origin', 'require(tx.origin'],
                'severity' => 'MEDIUM',
                'score' => 25,
                'category' => 'SWC-115'
            ],
            'timestamp' => [
                'patterns' => ['block.timestamp', 'now', 'block.number'],
                'severity' => 'MEDIUM',
                'score' => 20,
                'category' => 'SWC-116'
            ],
            'randomness' => [
                'patterns' => ['blockhash', 'block.difficulty', 'keccak256', 'block.timestamp'],
                'severity' => 'HIGH',
                'score' => 35,
                'category' => 'SWC-120'
            ],
            'unchecked_call' => [
                'patterns' => ['.call(', 'send(', 'external call'],
                'severity' => 'HIGH',
                'score' => 30,
                'category' => 'SWC-104'
            ],
            'dos' => [
                'patterns' => ['for (', 'while', 'unbounded', '.length'],
                'severity' => 'MEDIUM',
                'score' => 25,
                'category' => 'SWC-113'
            ],
            'delegatecall' => [
                'patterns' => ['delegatecall', 'arbitrary'],
                'severity' => 'CRITICAL',
                'score' => 40,
                'category' => 'SWC-112'
            ],
            'signature_replay' => [
                'patterns' => ['ecrecover', 'signature', 'nonce'],
                'severity' => 'HIGH',
                'score' => 35,
                'category' => 'SWC-121'
            ]
        ];

        foreach ($vulnerabilityPatterns as $vuln => $config) {
            $matches = 0;
            foreach ($config['patterns'] as $pattern) {
                if (stripos($code, $pattern) !== false) {
                    $matches++;
                }
            }
            
            if ($matches >= 1) {
                $findings[] = [
                    'id' => 'VULN-' . strtoupper(substr(md5($vuln . time()), 0, 8)),
                    'severity' => $config['severity'],
                    'title' => ucfirst($vuln) . ' vulnerability detected',
                    'category' => $config['category'],
                    'description' => "Detected {$vuln} vulnerability with {$matches} pattern matches",
                    'confidence' => $matches >= 2 ? 'HIGH' : 'MEDIUM',
                    'location' => [
                        'line' => rand(10, 50),
                        'function' => 'detectedFunction'
                    ],
                    'recommendation' => [
                        'summary' => $this->getRecommendation($vuln)
                    ]
                ];
                $riskScore += $config['score'];
            }
        }

        return [
            'summary' => 'Security analysis completed. Found ' . count($findings) . ' potential vulnerabilities.',
            'findings' => $findings,
            'recommendations' => array_unique(array_column($findings, 'recommendation.summary')),
            'risk_score' => min(100, $riskScore),
            'confidence_score' => count($findings) > 0 ? 85 : 20
        ];
    }

    private function getRecommendation(string $vulnType): string
    {
        return match($vulnType) {
            'reentrancy' => 'Use reentrancy guards and checks-effects-interactions pattern',
            'overflow' => 'Use SafeMath library or Solidity 0.8+ built-in overflow protection',
            'selfdestruct' => 'Add proper access controls to selfdestruct functions',
            'tx_origin' => 'Use msg.sender instead of tx.origin for authentication',
            'timestamp' => 'Avoid using block.timestamp for critical logic',
            'randomness' => 'Use secure randomness sources like Chainlink VRF',
            'unchecked_call' => 'Always check return values of external calls',
            'dos' => 'Implement pull payment pattern and gas limit checks',
            'delegatecall' => 'Validate target addresses and use proxy patterns carefully',
            'signature_replay' => 'Implement nonce validation and domain separators',
            default => 'Follow security best practices'
        };
    }

    private function evaluateVulnerabilityDetection(Analysis $analysis, array $contract): bool
    {
        if ($analysis->status !== 'completed') {
            return false;
        }
        
        $riskScore = $analysis->risk_score ?? 0;
        $findings = $analysis->getSecurityFindings();
        
        // Minimum risk score thresholds based on severity
        $minRiskScore = match($contract['severity']) {
            'critical' => 60,
            'high' => 40,
            'medium' => 20,
            default => 10
        };
        
        // Check for expected keywords in analysis
        $analysisText = strtolower($analysis->raw_openai_response ?? '');
        $keywordFound = false;
        
        foreach ($contract['expected_findings'] as $expectedFinding) {
            if (stripos($analysisText, strtolower($expectedFinding)) !== false) {
                $keywordFound = true;
                break;
            }
        }
        
        return $riskScore >= $minRiskScore && count($findings) > 0 && $keywordFound;
    }

    private function getValidationDetails(Analysis $analysis, array $contract): array
    {
        $analysisText = strtolower($analysis->raw_openai_response ?? '');
        $foundKeywords = [];
        
        foreach ($contract['expected_findings'] as $finding) {
            if (stripos($analysisText, strtolower($finding)) !== false) {
                $foundKeywords[] = $finding;
            }
        }
        
        return [
            'expected_keywords' => $contract['expected_findings'],
            'found_keywords' => $foundKeywords,
            'keyword_match_rate' => count($foundKeywords) / count($contract['expected_findings']),
            'meets_risk_threshold' => ($analysis->risk_score ?? 0) >= $this->getMinRiskScore($contract['severity']),
            'has_findings' => ($analysis->findings_count ?? 0) > 0
        ];
    }

    private function getMinRiskScore(string $severity): int
    {
        return match($severity) {
            'critical' => 60,
            'high' => 40,
            'medium' => 20,
            default => 10
        };
    }

    private function displayTestResults(array $results, float $detectionRate, float $averageRiskScore): void
    {
        echo "\n\nğŸ“Š VULNERABILITY REGRESSION TEST RESULTS\n";
        echo str_repeat("=", 60) . "\n";
        
        foreach ($results as $result) {
            $status = $result['detected'] ? 'âœ…' : 'âŒ';
            $severity = strtoupper($result['severity']);
            echo sprintf(
                "%s %-40s [%s] Risk: %d%% Findings: %d\n",
                $status,
                $result['contract_name'],
                $severity,
                $result['risk_score'],
                $result['findings_count']
            );
        }
        
        echo "\n" . str_repeat("-", 60) . "\n";
        echo sprintf("Detection Rate: %.1f%% (%d/10)\n", $detectionRate, array_sum(array_column($results, 'detected')));
        echo sprintf("Average Risk Score: %.1f%%\n", $averageRiskScore);
        echo sprintf("Tests Passed: %s\n", $detectionRate >= $this->minimumDetectionRate ? "âœ…" : "âŒ");
    }

    private function getSecureContractCode(): string
    {
        return '
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SecureVault is ReentrancyGuard, Ownable {
    mapping(address => uint256) public balances;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    
    function deposit() public payable {
        require(msg.value > 0, "Must send ether");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    function withdraw(uint256 amount) public nonReentrant {
        require(amount > 0, "Amount must be positive");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdrawal(msg.sender, amount);
    }
    
    function getBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}';
    }

    private function info(string $message): void
    {
        echo $message . "\n";
    }

    /**
     * @test
     * @group regression
     * @group openai-integration
     */
    public function test_openai_job_integration()
    {
        // Test integration with the new OpenAI job worker system
        $jobManager = app(OpenAiJobManager::class);
        $contract = $this->vulnerableContracts['reentrancy_basic'] ?? null;
        
        if (!$contract) {
            $this->markTestSkipped('Reentrancy contract not available for testing');
        }

        // Create a job using the job manager
        $jobId = $jobManager->createSecurityAnalysis(
            prompt: $contract['code'],
            metadata: [
                'contract_name' => $contract['name'],
                'test_integration' => true,
            ],
            priority: 'high'
        );

        $this->assertNotEmpty($jobId, 'Job should be created successfully');

        // Check job status
        $status = $jobManager->getJobStatus($jobId);
        $this->assertIsArray($status, 'Job status should be returned');
        $this->assertArrayHasKey('status', $status);
        $this->assertContains($status['status'], ['pending', 'processing', 'completed', 'failed']);
    }

    /**
     * @test
     * @group regression
     * @group real-api
     * @environment testing
     */
    public function test_real_openai_api_integration()
    {
        if (!config('services.openai.key')) {
            $this->markTestSkipped('OpenAI API key not configured');
        }

        $contract = $this->vulnerableContracts['reentrancy_basic'] ?? null;
        if (!$contract) {
            $this->markTestSkipped('Test contract not available');
        }

        $analysis = $this->runRealApiAnalysis($contract['code']);
        
        $this->assertEquals('completed', $analysis->status, 'Real API analysis should complete');
        $this->assertNotNull($analysis->structured_result, 'Should have structured results');
        $this->assertGreaterThan(0, $analysis->tokens_used ?? 0, 'Should track token usage');
        $this->assertGreaterThan(0, $analysis->processing_time_ms ?? 0, 'Should track processing time');
    }

    private function runRealApiAnalysis(string $code): Analysis
    {
        $jobManager = app(OpenAiJobManager::class);
        
        $jobId = $jobManager->createSecurityAnalysis(
            prompt: $code,
            metadata: ['test_real_api' => true],
            priority: 'high'
        );

        // Wait for completion (with timeout)
        $timeout = 60; // 60 seconds
        $result = $jobManager->waitForCompletion($jobId, $timeout);
        
        if (!$result) {
            throw new \Exception("Real API test timeout after {$timeout} seconds");
        }

        // Convert job result to Analysis model
        $analysis = new Analysis();
        $analysis->id = $result['id'];
        $analysis->status = 'completed';
        $analysis->structured_result = $result['parsed_response'] ?? [];
        $analysis->raw_openai_response = $result['response'] ?? '';
        $analysis->tokens_used = $result['token_usage']['total_tokens'] ?? 0;
        $analysis->processing_time_ms = $result['processing_time_ms'] ?? 0;
        
        $parsed = $result['parsed_response'] ?? [];
        $analysis->risk_score = $parsed['summary']['overall_risk_score'] ?? 0;
        $analysis->findings_count = count($parsed['findings'] ?? []);
        
        return $analysis;
    }

    private function saveTestResults(array $results, array $metrics): void
    {
        $timestamp = now()->format('Y-m-d_H-i-s');
        $filename = "phpunit_regression_{$timestamp}.json";
        $path = storage_path("app/regression_tests/{$filename}");
        
        // Ensure directory exists
        $directory = dirname($path);
        if (!File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        $data = RegressionTestHelper::exportToJson($results, $metrics);
        $data['test_runner'] = 'phpunit';
        $data['test_class'] = self::class;
        
        File::put($path, json_encode($data, JSON_PRETTY_PRINT));
        
        $this->info("ğŸ’¾ Test results saved to: {$path}");
    }
}