// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title FrontRunningVulnerable
 * @dev Contract vulnerable to front-running attacks
 * Based on commit-reveal and auction patterns
 */
contract FrontRunningVulnerable {
    struct Bid {
        address bidder;
        uint256 amount;
        bool revealed;
    }
    
    mapping(uint256 => Bid) public bids;
    uint256 public bidCounter;
    uint256 public auctionEnd;
    address public highestBidder;
    uint256 public highestBid;
    
    constructor() {
        auctionEnd = block.timestamp + 1 days;
    }
    
    // VULNERABILITY: Bid amount visible in mempool
    function bid() public payable {
        require(block.timestamp < auctionEnd, "Auction ended");
        
        // VULNERABILITY: All transaction data is visible before mining
        if (msg.value > highestBid) {
            highestBidder = msg.sender;
            highestBid = msg.value;
        }
        
        bidCounter++;
        bids[bidCounter] = Bid(msg.sender, msg.value, true);
    }
    
    // VULNERABILITY: Predictable randomness
    function drawWinner() public view returns (address) {
        require(block.timestamp > auctionEnd, "Auction still active");
        
        // VULNERABILITY: Block hash is predictable by miners
        uint256 random = uint256(blockhash(block.number - 1)) % bidCounter;
        return bids[random + 1].bidder;
    }
    
    // VULNERABILITY: Race condition in price setting
    uint256 public tokenPrice = 1 ether;
    
    function updatePrice(uint256 newPrice) public {
        require(msg.sender == highestBidder, "Only winner can update");
        tokenPrice = newPrice;
    }
    
    function buyTokens() public payable {
        uint256 tokens = msg.value / tokenPrice;
        // Vulnerable to sandwich attacks - price can be manipulated
        // between price check and execution
    }
}
