// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title FlashLoanVulnerable
 * @dev Contract vulnerable to flash loan attacks
 * Based on price manipulation and oracle attacks
 */
contract FlashLoanVulnerable {
    mapping(address => uint256) public tokenBalance;
    mapping(address => uint256) public ethBalance;
    
    uint256 public totalTokenSupply = 1000000 * 10**18;
    uint256 public totalEthBalance;
    
    // VULNERABILITY: Price calculated from contract's own reserves
    function getTokenPrice() public view returns (uint256) {
        if (totalEthBalance == 0) return 1 ether;
        
        // VULNERABILITY: Price can be manipulated by large trades
        return (totalEthBalance * 1 ether) / totalTokenSupply;
    }
    
    function buyTokens() public payable {
        require(msg.value > 0, "Must send ETH");
        
        uint256 tokenPrice = getTokenPrice();
        uint256 tokensToMint = (msg.value * 1 ether) / tokenPrice;
        
        tokenBalance[msg.sender] += tokensToMint;
        totalTokenSupply += tokensToMint;
        totalEthBalance += msg.value;
    }
    
    function sellTokens(uint256 tokenAmount) public {
        require(tokenBalance[msg.sender] >= tokenAmount, "Insufficient tokens");
        
        uint256 tokenPrice = getTokenPrice();
        uint256 ethToReturn = (tokenAmount * tokenPrice) / 1 ether;
        
        require(ethToReturn <= totalEthBalance, "Insufficient ETH reserves");
        
        tokenBalance[msg.sender] -= tokenAmount;
        totalTokenSupply -= tokenAmount;
        totalEthBalance -= ethToReturn;
        
        payable(msg.sender).transfer(ethToReturn);
    }
    
    // VULNERABILITY: Lending without proper checks
    mapping(address => uint256) public borrowed;
    
    function flashLoan(uint256 amount) public {
        require(amount <= totalEthBalance, "Insufficient liquidity");
        require(borrowed[msg.sender] == 0, "Already borrowed");
        
        borrowed[msg.sender] = amount;
        totalEthBalance -= amount;
        
        // Send ETH to borrower
        payable(msg.sender).transfer(amount);
        
        // VULNERABILITY: Assumes borrower will call repay in same transaction
        // But no mechanism enforces this
    }
    
    function repayFlashLoan() public payable {
        uint256 borrowedAmount = borrowed[msg.sender];
        require(borrowedAmount > 0, "No active loan");
        
        uint256 fee = borrowedAmount / 100; // 1% fee
        require(msg.value >= borrowedAmount + fee, "Insufficient repayment");
        
        borrowed[msg.sender] = 0;
        totalEthBalance += borrowedAmount + fee;
        
        // Return excess
        if (msg.value > borrowedAmount + fee) {
            payable(msg.sender).transfer(msg.value - borrowedAmount - fee);
        }
    }
    
    // VULNERABILITY: Oracle manipulation
    address public priceOracle;
    
    function setPriceOracle(address oracle) public {
        // VULNERABILITY: No access control
        priceOracle = oracle;
    }
    
    function getOraclePrice() public view returns (uint256) {
        if (priceOracle == address(0)) {
            return getTokenPrice(); // Falls back to manipulable price
        }
        
        // VULNERABILITY: Trusts external oracle without validation
        (bool success, bytes memory data) = priceOracle.staticcall(
            abi.encodeWithSignature("getPrice()")
        );
        
        if (success && data.length >= 32) {
            return abi.decode(data, (uint256));
        }
        
        return getTokenPrice(); // Fallback to vulnerable price
    }
    
    // VULNERABILITY: Time-weighted average that can be manipulated
    uint256[] public priceHistory;
    uint256 public lastPriceUpdate;
    
    function updatePrice() public {
        if (block.timestamp >= lastPriceUpdate + 1 hours) {
            priceHistory.push(getTokenPrice());
            lastPriceUpdate = block.timestamp;
            
            // Keep only last 24 prices
            if (priceHistory.length > 24) {
                for (uint i = 0; i < priceHistory.length - 1; i++) {
                    priceHistory[i] = priceHistory[i + 1];
                }
                priceHistory.pop();
            }
        }
    }
    
    function getTWAP() public view returns (uint256) {
        if (priceHistory.length == 0) return getTokenPrice();
        
        uint256 sum = 0;
        for (uint i = 0; i < priceHistory.length; i++) {
            sum += priceHistory[i];
        }
        
        return sum / priceHistory.length;
    }
}
