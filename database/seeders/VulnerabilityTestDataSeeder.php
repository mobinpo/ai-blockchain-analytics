<?php

declare(strict_types=1);

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\File;

final class VulnerabilityTestDataSeeder extends Seeder
{
    /**
     * Seed the vulnerability test data.
     */
    public function run(): void
    {
        $contractsPath = base_path('tests/VulnerableContracts');
        
        $vulnerabilityTestData = [
            [
                'contract_name' => 'ReentrancyVulnerable',
                'file' => 'KnownVulnerabilityContract1.sol',
                'vulnerability_type' => 'reentrancy',
                'risk_level' => 'critical',
                'expected_findings' => [
                    'Reentrancy vulnerability in withdraw function',
                    'External call before state update',
                    'Missing reentrancy guard',
                    'State changes after external call'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Malicious contract can call withdraw repeatedly before balance is updated',
                    'impact' => 'Complete contract fund drainage',
                    'cve_reference' => 'Similar to DAO attack 2016',
                    'mitigation' => 'Use ReentrancyGuard, checks-effects-interactions pattern'
                ]
            ],
            [
                'contract_name' => 'IntegerOverflowVulnerable',
                'file' => 'KnownVulnerabilityContract2.sol',
                'vulnerability_type' => 'integer_overflow',
                'risk_level' => 'high',
                'expected_findings' => [
                    'Integer overflow in transfer function',
                    'Integer underflow in burn function',
                    'Multiplication overflow in calculateReward',
                    'No SafeMath usage in Solidity 0.6.0'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Large values cause integer wraparound',
                    'impact' => 'Token balance manipulation, supply inflation',
                    'affected_versions' => 'Solidity < 0.8.0',
                    'mitigation' => 'Use SafeMath library or upgrade to Solidity 0.8+'
                ]
            ],
            [
                'contract_name' => 'AccessControlVulnerable',
                'file' => 'KnownVulnerabilityContract3.sol',
                'vulnerability_type' => 'broken_access_control',
                'risk_level' => 'critical',
                'expected_findings' => [
                    'Weak access control in setOwner function',
                    'Missing access control in addAdmin function',
                    'Inverted logic in setCriticalValue function',
                    'tx.origin vulnerability in emergencyWithdraw'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Privilege escalation, authorization bypass',
                    'impact' => 'Complete contract takeover',
                    'patterns' => ['tx.origin', 'inverted_logic', 'missing_modifier'],
                    'mitigation' => 'Proper access control modifiers, avoid tx.origin'
                ]
            ],
            [
                'contract_name' => 'UncheckedExternalCallVulnerable',
                'file' => 'KnownVulnerabilityContract4.sol',
                'vulnerability_type' => 'unchecked_external_call',
                'risk_level' => 'high',
                'expected_findings' => [
                    'Unchecked external call in becomeKing function',
                    'Unchecked low-level call in sendReward function',
                    'Dangerous delegatecall to user-controlled address',
                    'DoS via failed external calls'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Malicious contract prevents state changes via revert',
                    'impact' => 'Denial of service, stuck funds',
                    'similar_attacks' => ['King of Ether', 'Auction DoS'],
                    'mitigation' => 'Check return values, pull over push pattern'
                ]
            ],
            [
                'contract_name' => 'FrontRunningVulnerable',
                'file' => 'KnownVulnerabilityContract5.sol',
                'vulnerability_type' => 'front_running',
                'risk_level' => 'medium',
                'expected_findings' => [
                    'Bid amount visible in mempool before mining',
                    'Predictable randomness using blockhash',
                    'Race condition in price setting mechanism',
                    'MEV (Maximal Extractable Value) vulnerability'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Miners/bots observe pending transactions and front-run',
                    'impact' => 'Unfair advantage, value extraction',
                    'protection' => 'Commit-reveal scheme, batch auctions',
                    'mitigation' => 'Private mempools, time delays, fair ordering'
                ]
            ],
            [
                'contract_name' => 'TimestampDependenceVulnerable',
                'file' => 'KnownVulnerabilityContract6.sol',
                'vulnerability_type' => 'timestamp_manipulation',
                'risk_level' => 'medium',
                'expected_findings' => [
                    'Reliance on block.timestamp for critical logic',
                    'Predictable randomness using timestamp and difficulty',
                    'Insufficient timelock duration (1 minute)',
                    'Miner timestamp manipulation possible'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Miners can manipulate block.timestamp within limits',
                    'impact' => 'Timing-based attacks, randomness prediction',
                    'tolerance' => 'Â±15 seconds timestamp manipulation',
                    'mitigation' => 'Use block.number, external oracles, longer timelocks'
                ]
            ],
            [
                'contract_name' => 'UninitialisedStorageVulnerable',
                'file' => 'KnownVulnerabilityContract7.sol',
                'vulnerability_type' => 'uninitialized_storage',
                'risk_level' => 'high',
                'expected_findings' => [
                    'Uninitialized storage struct overwrites storage slot 0',
                    'Array bounds not checked leading to arbitrary storage read',
                    'Storage collision possible via delegatecall',
                    'Uninitialized function pointer vulnerability'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Uninitialized pointers reference storage slot 0',
                    'impact' => 'Storage corruption, privilege escalation',
                    'affected_versions' => 'All Solidity versions with storage structs',
                    'mitigation' => 'Always initialize storage variables, use memory'
                ]
            ],
            [
                'contract_name' => 'DenialOfServiceVulnerable',
                'file' => 'KnownVulnerabilityContract8.sol',
                'vulnerability_type' => 'denial_of_service',
                'risk_level' => 'high',
                'expected_findings' => [
                    'Unbounded loop in refundAll function',
                    'External call in loop causes DoS',
                    'Block gas limit DoS in array processing',
                    'Strict requirements causing unexpected reverts'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Cause functions to consume excessive gas or revert',
                    'impact' => 'Contract becomes unusable, funds locked',
                    'patterns' => ['unbounded_loops', 'external_call_loops', 'gas_griefing'],
                    'mitigation' => 'Pull pattern, pagination, gas limits'
                ]
            ],
            [
                'contract_name' => 'BadRandomnessVulnerable',
                'file' => 'KnownVulnerabilityContract9.sol',
                'vulnerability_type' => 'weak_randomness',
                'risk_level' => 'high',
                'expected_findings' => [
                    'Weak randomness using block variables',
                    'Predictable sequence using linear congruential generator',
                    'Recent blockhash manipulation vulnerability',
                    'Miner-influenced entropy sources'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Predict or influence random number generation',
                    'impact' => 'Gambling manipulation, unfair advantages',
                    'entropy_sources' => ['block.timestamp', 'blockhash', 'block.difficulty'],
                    'mitigation' => 'Chainlink VRF, commit-reveal, external oracles'
                ]
            ],
            [
                'contract_name' => 'FlashLoanVulnerable',
                'file' => 'KnownVulnerabilityContract10.sol',
                'vulnerability_type' => 'flash_loan_attack',
                'risk_level' => 'critical',
                'expected_findings' => [
                    'Price manipulation using contract reserves',
                    'Insufficient flash loan enforcement mechanisms',
                    'Oracle manipulation vulnerability',
                    'TWAP manipulation possible with large trades'
                ],
                'vulnerability_metadata' => [
                    'attack_vector' => 'Manipulate price oracles via large borrowed amounts',
                    'impact' => 'Massive value extraction, protocol insolvency',
                    'examples' => ['bZx attacks', 'Cream Finance', 'Harvest Finance'],
                    'mitigation' => 'Multiple oracles, TWAP, circuit breakers'
                ]
            ]
        ];

        DB::table('vulnerability_test_data')->truncate();

        foreach ($vulnerabilityTestData as $data) {
            $filePath = $contractsPath . '/' . $data['file'];
            
            if (File::exists($filePath)) {
                $contractCode = File::get($filePath);
                
                DB::table('vulnerability_test_data')->insert([
                    'contract_name' => $data['contract_name'],
                    'vulnerability_type' => $data['vulnerability_type'],
                    'risk_level' => $data['risk_level'],
                    'contract_code' => $contractCode,
                    'expected_findings' => json_encode($data['expected_findings']),
                    'vulnerability_metadata' => json_encode($data['vulnerability_metadata']),
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
            }
        }

        $this->command->info('âœ… Successfully seeded ' . count($vulnerabilityTestData) . ' vulnerability test cases');
        
        // Display seeded data summary
        $this->command->info('ðŸ“Š Vulnerability Test Data Summary:');
        
        $riskLevels = collect($vulnerabilityTestData)->groupBy('risk_level');
        foreach ($riskLevels as $level => $contracts) {
            $this->command->info("   {$level}: " . count($contracts) . " contracts");
        }
        
        $vulnerabilityTypes = collect($vulnerabilityTestData)->pluck('vulnerability_type')->unique();
        $this->command->info('ðŸ” Vulnerability types covered: ' . $vulnerabilityTypes->count());
        foreach ($vulnerabilityTypes as $type) {
            $this->command->info("   - {$type}");
        }
    }
}