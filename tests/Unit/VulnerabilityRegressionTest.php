<?php

declare(strict_types=1);

namespace Tests\Unit;

use Tests\TestCase;
use App\Services\SolidityCleanerService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\File;

/**
 * @group vulnerability-regression
 */
final class VulnerabilityRegressionTest extends TestCase
{
    use RefreshDatabase;

    private SolidityCleanerService $solidityCleanerService;
    private array $vulnerableContracts;

    protected function setUp(): void
    {
        parent::setUp();
        $this->solidityCleanerService = app(SolidityCleanerService::class);
        $this->loadVulnerableContracts();
    }

    private function loadVulnerableContracts(): void
    {
        $contractsPath = base_path('tests/VulnerableContracts');
        
        $this->vulnerableContracts = [
            'reentrancy' => [
                'file' => 'KnownVulnerabilityContract1.sol',
                'title' => 'Reentrancy Vulnerable Contract',
                'vulnerability_types' => ['reentrancy', 'external_call_before_state_update'],
                'risk_level' => 'critical',
                'expected_findings' => [
                    'Reentrancy vulnerability in withdraw function',
                    'External call before state update',
                    'Missing reentrancy guard'
                ]
            ],
            'integer_overflow' => [
                'file' => 'KnownVulnerabilityContract2.sol', 
                'title' => 'Integer Overflow Vulnerable Contract',
                'vulnerability_types' => ['integer_overflow', 'integer_underflow'],
                'risk_level' => 'high',
                'expected_findings' => [
                    'Integer overflow in transfer function',
                    'Integer underflow in burn function',
                    'Multiplication overflow in calculateReward'
                ]
            ],
            'access_control' => [
                'file' => 'KnownVulnerabilityContract3.sol',
                'title' => 'Access Control Vulnerable Contract',
                'vulnerability_types' => ['broken_access_control', 'tx_origin_vulnerability'],
                'risk_level' => 'critical'
            ]
        ];

        // Load actual contract content
        foreach ($this->vulnerableContracts as $key => &$contract) {
            $filePath = $contractsPath . '/' . $contract['file'];
            if (File::exists($filePath)) {
                $contract['content'] = File::get($filePath);
            }
        }
    }

    public function test_vulnerable_contracts_are_loaded(): void
    {
        $this->assertGreaterThan(0, count($this->vulnerableContracts));
        
        foreach ($this->vulnerableContracts as $key => $contract) {
            if (isset($contract['content'])) {
                $this->assertNotEmpty($contract['content']);
                $this->assertStringContainsString('pragma solidity', $contract['content']);
            }
        }
    }

    public function test_reentrancy_vulnerability_detection(): void
    {
        if (!isset($this->vulnerableContracts['reentrancy']['content'])) {
            $this->markTestSkipped('Reentrancy contract not loaded');
        }

        $contract = $this->vulnerableContracts['reentrancy'];
        $cleanedCode = $this->solidityCleanerService->quickCleanForPrompt($contract['content']);
        
        $this->assertStringContainsString('call{value:', $cleanedCode);
        $this->assertEquals('critical', $contract['risk_level']);
        $this->assertContains('reentrancy', $contract['vulnerability_types']);
    }

    public function test_access_control_vulnerability_detection(): void
    {
        if (!isset($this->vulnerableContracts['access_control']['content'])) {
            $this->markTestSkipped('Access control contract not loaded');
        }

        $contract = $this->vulnerableContracts['access_control'];
        $cleanedCode = $this->solidityCleanerService->quickCleanForPrompt($contract['content']);
        
        $this->assertStringContainsString('tx.origin', $cleanedCode);
        $this->assertEquals('critical', $contract['risk_level']);
        $this->assertContains('tx_origin_vulnerability', $contract['vulnerability_types']);
    }

    public function test_contracts_can_be_cleaned_for_analysis(): void
    {
        foreach ($this->vulnerableContracts as $key => $contract) {
            if (!isset($contract['content'])) continue;
            
            $originalSize = strlen($contract['content']);
            $cleanedCode = $this->solidityCleanerService->quickCleanForPrompt($contract['content']);
            $cleanedSize = strlen($cleanedCode);
            
            $this->assertLessThan($originalSize, $cleanedSize);
            $this->assertStringContainsString('contract ', $cleanedCode);
        }
    }
}