// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title TimestampDependenceVulnerable
 * @dev Contract vulnerable to timestamp manipulation
 * Based on time-dependent lottery and vesting contracts
 */
contract TimestampDependenceVulnerable {
    mapping(address => uint256) public vestingStart;
    mapping(address => uint256) public vestingAmount;
    uint256 public constant VESTING_DURATION = 365 days;
    
    uint256 public lotteryEnd;
    address[] public participants;
    bool public lotteryFinalized;
    
    constructor() {
        lotteryEnd = block.timestamp + 7 days;
    }
    
    // VULNERABILITY: Reliance on block.timestamp
    function startVesting(address beneficiary, uint256 amount) public {
        vestingStart[beneficiary] = block.timestamp; // Miner can manipulate
        vestingAmount[beneficiary] = amount;
    }
    
    function claimVestedTokens() public {
        require(vestingAmount[msg.sender] > 0, "No vesting");
        
        // VULNERABILITY: Timestamp can be manipulated by miners (Â±15 seconds)
        require(block.timestamp >= vestingStart[msg.sender] + VESTING_DURATION, "Not vested yet");
        
        uint256 amount = vestingAmount[msg.sender];
        vestingAmount[msg.sender] = 0;
        
        payable(msg.sender).transfer(amount);
    }
    
    // VULNERABILITY: Using block.timestamp for random number generation
    function participateInLottery() public payable {
        require(msg.value >= 0.1 ether, "Minimum 0.1 ETH");
        require(block.timestamp < lotteryEnd, "Lottery ended");
        
        participants.push(msg.sender);
    }
    
    function finalizeLottery() public {
        require(block.timestamp >= lotteryEnd, "Lottery still active");
        require(!lotteryFinalized, "Already finalized");
        
        // VULNERABILITY: Predictable randomness using timestamp
        uint256 winnerIndex = (block.timestamp + block.difficulty) % participants.length;
        address winner = participants[winnerIndex];
        
        lotteryFinalized = true;
        payable(winner).transfer(address(this).balance);
    }
    
    // VULNERABILITY: Short timelock
    mapping(address => uint256) public withdrawalRequests;
    
    function requestWithdrawal() public {
        withdrawalRequests[msg.sender] = block.timestamp + 1 minutes; // Too short
    }
    
    function executeWithdrawal() public {
        require(block.timestamp >= withdrawalRequests[msg.sender], "Timelock not expired");
        // Withdraw logic here
    }
}
